"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCoreRule = exports.defineWrapperListener = exports.createRule = void 0;
function createRule(ruleName, rule) {
    return {
        meta: Object.assign(Object.assign({}, rule.meta), { docs: Object.assign(Object.assign({}, rule.meta.docs), { url: `https://ota-meshi.github.io/eslint-plugin-jsonc/rules/${ruleName}.html`, ruleId: `jsonc/${ruleName}`, ruleName }) }),
        create: rule.create,
    };
}
exports.createRule = createRule;
function defineWrapperListener(coreRule, context, options) {
    if (!context.parserServices.isJSON) {
        return {};
    }
    const listener = coreRule.create({
        __proto__: context,
        options,
    });
    const jsonListener = {};
    for (const key of Object.keys(listener)) {
        const original = listener[key];
        const jsonKey = key.replace(/(?:^|\b)(ExpressionStatement|ArrayExpression|ObjectExpression|Property|Identifier|Literal|UnaryExpression)(?:\b|$)/gu, "JSON$1");
        jsonListener[jsonKey] = function (node, ...args) {
            original.call(this, getProxyNode(node), ...args);
        };
    }
    function isNode(data) {
        return (data &&
            typeof data.type === "string" &&
            Array.isArray(data.range) &&
            data.range.length === 2 &&
            typeof data.range[0] === "number" &&
            typeof data.range[1] === "number");
    }
    function getProxyNode(node) {
        const type = node.type.startsWith("JSON")
            ? node.type.slice(4)
            : node.type;
        const cache = { type };
        return new Proxy(node, {
            get(_t, key) {
                if (key in cache) {
                    return cache[key];
                }
                const data = node[key];
                if (isNode(data)) {
                    return (cache[key] = getProxyNode(data));
                }
                if (Array.isArray(data)) {
                    return (cache[key] = data.map((e) => isNode(e) ? getProxyNode(e) : e));
                }
                return data;
            },
        });
    }
    return jsonListener;
}
exports.defineWrapperListener = defineWrapperListener;
let ruleMap = null;
function getCoreRule(name) {
    let map;
    if (ruleMap) {
        map = ruleMap;
    }
    else {
        ruleMap = map = new (require("eslint").Linter)().getRules();
    }
    return map.get(name);
}
exports.getCoreRule = getCoreRule;
