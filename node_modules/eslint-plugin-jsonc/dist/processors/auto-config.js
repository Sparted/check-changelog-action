"use strict";
const rules_1 = require("../utils/rules");
let engine, ruleNames;
function getCLIEngine() {
    if (engine) {
        return engine;
    }
    engine = new (require("eslint").CLIEngine)({});
    engine.addPlugin("eslint-plugin-jsonc", require(".."));
    return engine;
}
function getConfig(filename) {
    return getCLIEngine().getConfigForFile(filename);
}
function getJsoncRule(rule) {
    ruleNames = ruleNames || new Set(rules_1.rules.map((r) => r.meta.docs.ruleName));
    return ruleNames.has(rule) ? `jsonc/${rule}` : null;
}
const targetCache = new Map();
module.exports = {
    preprocess(code, filename) {
        const config = getConfig(filename);
        if (config.rules) {
            const autoConfig = {};
            for (const ruleName of Object.keys(config.rules)) {
                const jsoncName = getJsoncRule(ruleName);
                if (jsoncName && !config.rules[jsoncName]) {
                    const entry = config.rules[ruleName];
                    if (entry && entry !== "off") {
                        autoConfig[jsoncName] = entry;
                    }
                }
            }
            if (Object.keys(autoConfig).length) {
                const prefix = `/*eslint ${JSON.stringify(autoConfig)}*/\n\n\n`;
                targetCache.set(filename, { prefix, code });
                return [`${prefix}${code}`];
            }
        }
        return [code];
    },
    postprocess(messages, filename) {
        const info = targetCache.get(filename);
        if (info) {
            const offset = info.prefix.length;
            targetCache.delete(filename);
            return messages[0]
                .map((message) => {
                if (message.line <= 3) {
                    return null;
                }
                return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, message), { line: message.line - 3 }), (message.endLine != null
                    ? { endLine: message.endLine - 3 }
                    : {})), (message.fix != null
                    ? {
                        fix: Object.assign(Object.assign({}, message.fix), { range: [
                                message.fix.range[0] - offset,
                                message.fix.range[1] - offset,
                            ] }),
                    }
                    : {})), (message.suggestions != null
                    ? {
                        suggestions: message.suggestions.map((s) => (Object.assign(Object.assign({}, s), { fix: Object.assign(Object.assign({}, s.fix), { range: [
                                    s.fix.range[0] - offset,
                                    s.fix.range[1] - offset,
                                ] }) }))),
                    }
                    : {}));
            })
                .filter((m) => m != null);
        }
        return messages[0];
    },
    supportsAutofix: true,
};
