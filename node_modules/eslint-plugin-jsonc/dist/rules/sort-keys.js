"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const natural_compare_1 = __importDefault(require("natural-compare"));
const utils_1 = require("../utils");
const eslint_utils_1 = require("eslint-utils");
const jsonc_eslint_parser_1 = require("jsonc-eslint-parser");
function getPropertyName(node) {
    const prop = node.key;
    if (prop.type === "JSONIdentifier") {
        return prop.name;
    }
    return String(jsonc_eslint_parser_1.getStaticJSONValue(prop));
}
function buildValidator(order, insensitive, natural) {
    let compare = natural
        ? ([a, b]) => natural_compare_1.default(a, b) <= 0
        : ([a, b]) => a <= b;
    if (insensitive) {
        const baseCompare = compare;
        compare = ([a, b]) => baseCompare([a.toLowerCase(), b.toLowerCase()]);
    }
    if (order === "desc") {
        const baseCompare = compare;
        compare = (args) => baseCompare(args.reverse());
    }
    return (a, b) => compare([a, b]);
}
const allowOptions = ["asc", "desc"];
exports.default = utils_1.createRule("sort-keys", {
    meta: {
        docs: {
            description: "require object keys to be sorted",
            recommended: null,
            extensionRule: true,
        },
        fixable: "code",
        schema: [
            {
                enum: allowOptions,
            },
            {
                type: "object",
                properties: {
                    caseSensitive: {
                        type: "boolean",
                        default: true,
                    },
                    natural: {
                        type: "boolean",
                        default: false,
                    },
                    minKeys: {
                        type: "integer",
                        minimum: 2,
                        default: 2,
                    },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.",
        },
        type: "suggestion",
    },
    create(context) {
        const order = context.options[0] || "asc";
        const options = context.options[1];
        const insensitive = options && options.caseSensitive === false;
        const natural = options && options.natural;
        const minKeys = options && options.minKeys;
        const isValidOrder = buildValidator(order, insensitive, natural);
        let stack = { upper: null, prevList: [], numKeys: 0 };
        return {
            JSONObjectExpression(node) {
                stack = {
                    upper: stack,
                    prevList: [],
                    numKeys: node.properties.length,
                };
            },
            "JSONObjectExpression:exit"() {
                stack = stack.upper;
            },
            JSONProperty(node) {
                const prevList = stack.prevList;
                const numKeys = stack.numKeys;
                const thisName = getPropertyName(node);
                stack.prevList = [
                    {
                        name: thisName,
                        node,
                    },
                    ...prevList,
                ];
                if (prevList.length === 0 || numKeys < minKeys) {
                    return;
                }
                const prevName = prevList[0].name;
                if (!isValidOrder(prevName, thisName)) {
                    context.report({
                        loc: node.key.loc,
                        messageId: "sortKeys",
                        data: {
                            thisName,
                            prevName,
                            order,
                            insensitive: insensitive ? "insensitive " : "",
                            natural: natural ? "natural " : "",
                        },
                        *fix(fixer) {
                            const sourceCode = context.getSourceCode();
                            let moveTarget = prevList[0].node;
                            for (const prev of prevList) {
                                if (isValidOrder(prev.name, thisName)) {
                                    break;
                                }
                                else {
                                    moveTarget = prev.node;
                                }
                            }
                            const beforeToken = sourceCode.getTokenBefore(node);
                            const afterToken = sourceCode.getTokenAfter(node);
                            const hasAfterComma = eslint_utils_1.isCommaToken(afterToken);
                            const codeStart = beforeToken.range[1];
                            const codeEnd = hasAfterComma
                                ? afterToken.range[1]
                                : node.range[1];
                            const removeStart = hasAfterComma
                                ? codeStart
                                : beforeToken.range[0];
                            const insertCode = sourceCode.text.slice(codeStart, codeEnd) +
                                (hasAfterComma ? "" : ",");
                            const insertTarget = sourceCode.getTokenBefore(moveTarget);
                            yield fixer.insertTextAfterRange(insertTarget.range, insertCode);
                            yield fixer.removeRange([removeStart, codeEnd]);
                        },
                    });
                }
            },
        };
    },
});
