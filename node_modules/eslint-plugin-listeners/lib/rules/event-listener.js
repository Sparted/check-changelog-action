"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRule = void 0;
const utils_1 = require("../utils");
var ListenerType;
(function (ListenerType) {
    ListenerType["ADD_EVENT_LISTENER"] = "addEventListener";
    ListenerType["REMOVE_EVENT_LISTENER"] = "removeEventListener";
})(ListenerType || (ListenerType = {}));
const PLAIN_FUNCTION = 'plain function';
const ARROW_FUNCTION = 'arrow function';
const isProhibitedHandler = (type) => type === PLAIN_FUNCTION || type === ARROW_FUNCTION;
const reportMissingListener = (context, element, eventName, loc) => {
    context.report({
        loc,
        message: `${eventName} on ${element} does not have ` + 'a corresponding removeEventListener',
    });
};
const reportListenersDoNoMatch = (context, element, eventName, add, remove, loc) => {
    context.report({
        loc,
        message: `${add} and ${remove} on ${element} for ${eventName} do not match`,
    });
};
const reportProhibitedListener = (context, element, eventName, type, loc) => {
    context.report({
        loc,
        message: `event handler for ${eventName} on ${element} is ${type} ` + `${type}s are prohibited as event handlers`,
    });
};
const callExpressionListener = (listeners) => (node) => {
    var _a;
    if (utils_1.isNodeMemberExpression(node.callee)) {
        const callee = node.callee;
        const listenerType = (_a = callee.property) === null || _a === void 0 ? void 0 : _a.name;
        if ([ListenerType.ADD_EVENT_LISTENER, ListenerType.REMOVE_EVENT_LISTENER].includes(listenerType)) {
            const element = utils_1.parseMemberExpression(callee);
            const eventName = node.arguments[0].value;
            const handler = node.arguments[1];
            let func;
            if (utils_1.isNodeFunctionExpression(handler)) {
                func = PLAIN_FUNCTION;
            }
            else if (utils_1.isNodeArrowFunctionExpression(handler)) {
                func = ARROW_FUNCTION;
            }
            else if (utils_1.isNodeIdentifier(handler)) {
                func = handler.name;
            }
            else {
                func = utils_1.parseMemberExpression(handler);
            }
            const currentTypeListeners = listeners[listenerType] || {};
            listeners[listenerType] = Object.assign(Object.assign({}, currentTypeListeners), { [element]: Object.assign(Object.assign({}, currentTypeListeners[element]), { [eventName]: {
                        func,
                        loc: node.loc,
                    } }) });
        }
    }
};
const programListener = (ruleName, listeners, context) => () => {
    var _a, _b;
    const addListeners = (_a = listeners[ListenerType.ADD_EVENT_LISTENER]) !== null && _a !== void 0 ? _a : {};
    const removeListeners = (_b = listeners[ListenerType.REMOVE_EVENT_LISTENER]) !== null && _b !== void 0 ? _b : {};
    Object.keys(addListeners).forEach((element) => {
        const addEvents = addListeners[element];
        const removeEvents = removeListeners[element];
        Object.entries(addEvents).forEach(([eventName, { func, loc }]) => {
            const event = removeEvents === null || removeEvents === void 0 ? void 0 : removeEvents[eventName];
            switch (ruleName) {
                case utils_1.RuleType.MissingRemoveEventListener:
                    if (!event) {
                        reportMissingListener(context, element, eventName, loc);
                    }
                    break;
                case utils_1.RuleType.InlineFunctionEventListener:
                    if (isProhibitedHandler(func)) {
                        reportProhibitedListener(context, element, eventName, func, loc);
                    }
                    break;
                case utils_1.RuleType.MatchingRemoveEventListener:
                    if (removeEvents[eventName].func !== func) {
                        reportListenersDoNoMatch(context, element, eventName, func, event.func, loc);
                    }
                    break;
            }
        });
    });
};
exports.createRule = (ruleName) => ({
    meta: {
        docs: {
            description: utils_1.getDescription(ruleName),
            category: 'Best Practices',
            recommended: true,
            url: 'https://github.com/foad/eslint-plugin-listeners',
        },
        schema: [],
    },
    create: (context) => {
        const listeners = {};
        return {
            'CallExpression:exit': callExpressionListener(listeners),
            'Program:exit': programListener(ruleName, listeners, context),
        };
    },
});
